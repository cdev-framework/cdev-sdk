<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>src.cdev.parser.parser_utils API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.cdev.parser.parser_utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import ast
import os

from src.cdev.parser.parser_objects import *
from src.cdev.parser.cdev_parser_exceptions import *


def _get_global_variables_in_symboltable(table):
    # TODO Change error that is raised
    if not isinstance(table, symtable.SymbolTable):
        raise FileNotFoundError(&#34;tmp&#34;)

    symbols = table.get_symbols()

    rv_variables = set()

    for sym in symbols:
        # Check all symbols to see if they are not a namespace. If not then they are a normal symbols for this symboltable.
        if not sym.is_namespace():
            if sym.is_global():
                rv_variables.add(sym.get_name())

    return rv_variables

def _get_imported_variables_in_symboltable(table):
    # TODO Change error that is raised
    if not isinstance(table, symtable.SymbolTable):
        raise FileNotFoundError(&#34;tmp&#34;)

    symbols = table.get_symbols()

    rv_variables = set()

    for sym in symbols:
        # Check all symbols to see if they are not a namespace. If not then they are a normal symbols for this symboltable.
        if not sym.is_namespace():
            if sym.is_imported():
                rv_variables.add(sym.get_name())

    return rv_variables


def _get_local_variables_in_symboltable(table):
    # TODO Change error that is raised
    if not isinstance(table, symtable.SymbolTable):
        raise FileNotFoundError(&#34;tmp&#34;)

    symbols = table.get_symbols()

    rv_variables = set()

    for sym in symbols:
        # Check all symbols to see if they are not a namespace. If not then they are a normal gloabl variable for this symboltable.
        if not sym.is_namespace():
            #print(
            #    f&#34;{sym.get_name()}: {sym.is_imported()}; {sym.is_free()}; {sym.is_global()}; {sym.is_local()}&#34;
            #)
            if not sym.is_imported() and not sym.is_free(
            ) and not sym.is_global():
                rv_variables.add(sym.get_name())

    return rv_variables


def _get_functions_in_symboltable(table):
    # TODO Change error that is raised
    if not isinstance(table, symtable.SymbolTable):
        raise FileNotFoundError(&#34;tmp&#34;)

    symbols = table.get_symbols()

    rv_functions = set()

    for sym in symbols:
        # Check all symbols to see if they are a namespace (only functions and classes are namespaces)
        if sym.is_namespace():
            for ns in sym.get_namespaces():
                # A symbol can have multiple bindings so we need to see if any of them are functions
                if isinstance(ns, symtable.Function):
                    rv_functions.add(sym.get_name())
                    continue

    return rv_functions


def _generate_global_statement(file_info_obj, info):
    # This function is used to determine the type of global statement the node is and create the corresponding global statement obj
    ast_node = info[0]
    start_line = info[1]
    last_line = info[2]

    tmp_src_code = file_info_obj.get_lines_of_source_code(start_line, last_line)
    
    tmp_symbol_table = symtable.symtable(tmp_src_code, file_info_obj.file_location, &#39;exec&#39;)
    
    symbol_table = tmp_symbol_table   

    # If the symbol table is a function then it will appear as a single symbol that is a namespace 
    if len(tmp_symbol_table.get_symbols()) == 1:
        single_symbol = tmp_symbol_table.get_symbols()[0]
        if single_symbol.is_namespace():
            if isinstance(single_symbol.get_namespaces()[0], symtable.Function):
                print(f&#34;{single_symbol.get_name()} is function&#34;)
                name = single_symbol.get_name()
                fs = FunctionStatement( ast_node, [start_line, last_line], single_symbol.get_namespaces()[0], name)
                file_info_obj.add_global_function(name, fs)
                return

    ts = {s.get_name() for s in tmp_symbol_table.get_symbols()}

    used_imported_symbols = file_info_obj.imported_symbols.intersection(ts)
    if len(used_imported_symbols ) &gt; 0:
        # This statement uses an imported symbol so we need to check it to see if it is the import statement
        for n in ast.walk(ast_node):
            if isinstance(n, ast.Import):
                print(f&#34;IMPORT: {n}&#34;)
                #print(f&#34;FIELDS { [(cn.name, cn.asname)  for cn in n.names] }&#34;)
                for imprt in n.names:
                    print(f&#34;FIELDS: {imprt.name}; {imprt.asname}&#34;)
                    if not imprt.asname:
                        asname = imprt.name
                    else:
                        asname = imprt.asname

                    imp_statement = ImportStatement(ast_node, [start_line, last_line], symbol_table , asname, imprt.name)
                    file_info_obj.add_global_import(imp_statement)
                    continue

            if isinstance(n, ast.ImportFrom):
                print(f&#34;IMPORT FROM: {n}&#34;)

    global_statement_obj = GlobalStatement(ast_node, [start_line,last_line], symbol_table)
    file_info_obj.add_global_statement(global_statement_obj) 


def get_file_information(file_path, include_functions=[]):
    if not os.path.isfile(file_path):
        raise FileNotFoundError(
            f&#34;cdev_parser: could not find file at -&gt; {file_path}&#34;)

    file_info_obj = file_information(file_path)

    symbol_table = file_info_obj.get_symbol_table()

    try:
        functions = _get_functions_in_symboltable(symbol_table)
        file_info_obj.function_names = functions

        local_variables = _get_local_variables_in_symboltable(symbol_table)

        imported_symbols = _get_imported_variables_in_symboltable(symbol_table)
        print(imported_symbols)
    
        global_symbols = _get_global_variables_in_symboltable(symbol_table)
    except FileNotFoundError as e:
        print(e)

    for item in functions.union(local_variables).union(imported_symbols).union(global_symbols):
        file_info_obj.symbol_to_statement[item] = set()

    file_info_obj.set_imported_symbols(imported_symbols)

    
    # Need to get the line range of each global statement, but this requires looping over all the global nodes in the ast
    # in the top level of the file. To support earlier versions of python &lt;3.7 we must use the starting line of 
    # the next statement as the last line of previous node. We are going to store this info in a tmp dict then
    # once we have all the information create the objects

    file_ast = file_info_obj.get_ast()

    # dict&lt;ast.node, [line1,line2]&gt;
    _tmp_global_information = {}

    previous_node = None
    for node in file_ast.body:
        if previous_node:
            prev_vals = _tmp_global_information.get(previous_node)
            prev_vals.append(node.lineno-1)
            _tmp_global_information[previous_node]

        _tmp_global_information[node] = [node,node.lineno]

        previous_node = node

    # Set the last line of the last global statement to the last line of the file
    prev_vals = _tmp_global_information.get(previous_node)
    prev_vals.append(file_info_obj.get_file_length()+1)
    _tmp_global_information[previous_node]


    # Now that the information has been collected for the global statements, we can create the actual objs and add
    # them to the file_info_obj 
    for k in _tmp_global_information:
        _generate_global_statement(file_info_obj, _tmp_global_information.get(k))

    EXCLUDED_SYMBOLS = set([&#34;os&#34;, &#34;print&#34;, &#34;sss&#34;])

    # Build a two-way binding of a symbol to statement and a statement to a symbol.
    # This information is needed to get all dependencies of symbols, which is needed
    # to reconstruct just the nessecary lines
    for i in file_info_obj.get_global_statements():
        syms = i.get_symbols()
        for sym in syms:
            if not sym.get_name() in file_info_obj.symbol_to_statement:
                continue

            if sym.get_name() in EXCLUDED_SYMBOLS:
                continue

            # Add all the symbols in the statement to the list of this global statement
            if i in file_info_obj.statement_to_symbol:
                tmp = file_info_obj.statement_to_symbol.get(i)
                tmp.add(sym.get_name())
                file_info_obj.statement_to_symbol[i] = tmp

            # Since this global statement is a top level function... the code that effects this symbol within it will only execute if the 
            # function itself is called. Therefor, other functions can use this symbol without depending on that actual function it is in. 
            if i.get_type() == GlobalStatementType.FUNCTION:
                continue

            tmp = file_info_obj.symbol_to_statement.get(sym.get_name())
            tmp.add(i)
            file_info_obj.symbol_to_statement[sym.get_name()] = tmp

        if i.get_type() == GlobalStatementType.FUNCTION:
            tmp = file_info_obj.symbol_to_statement.get(i.get_function_name())
            tmp.add(i)
            file_info_obj.symbol_to_statement[i.get_function_name()] = tmp


    # If a list of functions was not included then parse all top level functions
    if not include_functions:
        include_functions = file_info_obj.global_functions.keys()


    for function_name in include_functions:
        # Create new parsed function obj
        p_function = parsed_function(function_name)

        # Get the Global obj associated with the current function
        func_glob_obj = file_info_obj.global_functions.get(function_name)

        # Add the functions lines to the parsed function
        p_function.add_line_numbers(func_glob_obj.get_line_no())

        # Start with a set that already includes the global statement for itself
        already_included_global_obj = set([func_glob_obj])

        # Start with a set that already includes the symbol for itself
        already_included_symbols = set([function_name])

        # next symbols is the set of symbols that need their dependant global statements
        next_symbols =  file_info_obj.statement_to_symbol.get(func_glob_obj)

        keep_looping = True
        remaining_symbols = set()

        # Some symbols won&#39;t be included in the mapping because they are excluded, but they need to be kept track of to look at imports
        all_used_symbols = set([g.get_name() for g in func_glob_obj.get_symbols()])

        while keep_looping:
            # If there are no more symbols than break the loop
            if not next_symbols:
                break 
            
            # Add the previous iterations symbols as already seen so they are not readded
            already_included_symbols = already_included_symbols.union(remaining_symbols)
            remaining_symbols = next_symbols
            next_symbols = set()

            for sym in remaining_symbols:
                if sym in already_included_symbols:
                    # If we have already added this symbol than we have all of its dependencies
                    continue

                # Add all dependant global statements to this symbol needs to the need lines for the function
                for glob_obj in file_info_obj.symbol_to_statement.get(sym):
                    
                    if glob_obj in already_included_global_obj:
                        #IF this global statement has already been added continue
                        continue

                    # Add the lines numbers and place it in the already included set
                    p_function.add_line_numbers(glob_obj.get_line_no())
                    already_included_global_obj.add(glob_obj)


                    # include this statements 
                    all_used_symbols = all_used_symbols.union(set(g.get_name() for g in glob_obj.get_symbols()))

                    # Get the set of symbols that this statement depends on
                    set_symbols = file_info_obj.statement_to_symbol.get(glob_obj)
                    # Remove the symbols that have already been included
                    new_needed_symbols = set_symbols.difference(already_included_symbols) 
                    actual_new_needed_symbols = new_needed_symbols.difference(remaining_symbols)
                    #print(f&#34;------------------{actual_new_needed_symbols}&#34;)
                    # Add the actually needed new symbols to the set of symbols to be looped over next
                    next_symbols = next_symbols.union(actual_new_needed_symbols)

        print(f&#34;{function_name}: {all_used_symbols}&#34;)
        for s in all_used_symbols:
            if s in file_info_obj.imported_symbol_to_global_statement:
                print(f&#34;ADDING {s} import statement to {function_name}&#34;)
                p_function.add_line_numbers(file_info_obj.imported_symbol_to_global_statement.get(s).get_line_no())

        #finally add the parsed function object to the file info
        file_info_obj.add_parsed_functions(p_function)
                   

    for f in file_info_obj.parsed_functions:
        print(f&#34;{f.needed_line_numbers}&#34;)


    return file_info_obj</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.cdev.parser.parser_utils.get_file_information"><code class="name flex">
<span>def <span class="ident">get_file_information</span></span>(<span>file_path, include_functions=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_file_information(file_path, include_functions=[]):
    if not os.path.isfile(file_path):
        raise FileNotFoundError(
            f&#34;cdev_parser: could not find file at -&gt; {file_path}&#34;)

    file_info_obj = file_information(file_path)

    symbol_table = file_info_obj.get_symbol_table()

    try:
        functions = _get_functions_in_symboltable(symbol_table)
        file_info_obj.function_names = functions

        local_variables = _get_local_variables_in_symboltable(symbol_table)

        imported_symbols = _get_imported_variables_in_symboltable(symbol_table)
        print(imported_symbols)
    
        global_symbols = _get_global_variables_in_symboltable(symbol_table)
    except FileNotFoundError as e:
        print(e)

    for item in functions.union(local_variables).union(imported_symbols).union(global_symbols):
        file_info_obj.symbol_to_statement[item] = set()

    file_info_obj.set_imported_symbols(imported_symbols)

    
    # Need to get the line range of each global statement, but this requires looping over all the global nodes in the ast
    # in the top level of the file. To support earlier versions of python &lt;3.7 we must use the starting line of 
    # the next statement as the last line of previous node. We are going to store this info in a tmp dict then
    # once we have all the information create the objects

    file_ast = file_info_obj.get_ast()

    # dict&lt;ast.node, [line1,line2]&gt;
    _tmp_global_information = {}

    previous_node = None
    for node in file_ast.body:
        if previous_node:
            prev_vals = _tmp_global_information.get(previous_node)
            prev_vals.append(node.lineno-1)
            _tmp_global_information[previous_node]

        _tmp_global_information[node] = [node,node.lineno]

        previous_node = node

    # Set the last line of the last global statement to the last line of the file
    prev_vals = _tmp_global_information.get(previous_node)
    prev_vals.append(file_info_obj.get_file_length()+1)
    _tmp_global_information[previous_node]


    # Now that the information has been collected for the global statements, we can create the actual objs and add
    # them to the file_info_obj 
    for k in _tmp_global_information:
        _generate_global_statement(file_info_obj, _tmp_global_information.get(k))

    EXCLUDED_SYMBOLS = set([&#34;os&#34;, &#34;print&#34;, &#34;sss&#34;])

    # Build a two-way binding of a symbol to statement and a statement to a symbol.
    # This information is needed to get all dependencies of symbols, which is needed
    # to reconstruct just the nessecary lines
    for i in file_info_obj.get_global_statements():
        syms = i.get_symbols()
        for sym in syms:
            if not sym.get_name() in file_info_obj.symbol_to_statement:
                continue

            if sym.get_name() in EXCLUDED_SYMBOLS:
                continue

            # Add all the symbols in the statement to the list of this global statement
            if i in file_info_obj.statement_to_symbol:
                tmp = file_info_obj.statement_to_symbol.get(i)
                tmp.add(sym.get_name())
                file_info_obj.statement_to_symbol[i] = tmp

            # Since this global statement is a top level function... the code that effects this symbol within it will only execute if the 
            # function itself is called. Therefor, other functions can use this symbol without depending on that actual function it is in. 
            if i.get_type() == GlobalStatementType.FUNCTION:
                continue

            tmp = file_info_obj.symbol_to_statement.get(sym.get_name())
            tmp.add(i)
            file_info_obj.symbol_to_statement[sym.get_name()] = tmp

        if i.get_type() == GlobalStatementType.FUNCTION:
            tmp = file_info_obj.symbol_to_statement.get(i.get_function_name())
            tmp.add(i)
            file_info_obj.symbol_to_statement[i.get_function_name()] = tmp


    # If a list of functions was not included then parse all top level functions
    if not include_functions:
        include_functions = file_info_obj.global_functions.keys()


    for function_name in include_functions:
        # Create new parsed function obj
        p_function = parsed_function(function_name)

        # Get the Global obj associated with the current function
        func_glob_obj = file_info_obj.global_functions.get(function_name)

        # Add the functions lines to the parsed function
        p_function.add_line_numbers(func_glob_obj.get_line_no())

        # Start with a set that already includes the global statement for itself
        already_included_global_obj = set([func_glob_obj])

        # Start with a set that already includes the symbol for itself
        already_included_symbols = set([function_name])

        # next symbols is the set of symbols that need their dependant global statements
        next_symbols =  file_info_obj.statement_to_symbol.get(func_glob_obj)

        keep_looping = True
        remaining_symbols = set()

        # Some symbols won&#39;t be included in the mapping because they are excluded, but they need to be kept track of to look at imports
        all_used_symbols = set([g.get_name() for g in func_glob_obj.get_symbols()])

        while keep_looping:
            # If there are no more symbols than break the loop
            if not next_symbols:
                break 
            
            # Add the previous iterations symbols as already seen so they are not readded
            already_included_symbols = already_included_symbols.union(remaining_symbols)
            remaining_symbols = next_symbols
            next_symbols = set()

            for sym in remaining_symbols:
                if sym in already_included_symbols:
                    # If we have already added this symbol than we have all of its dependencies
                    continue

                # Add all dependant global statements to this symbol needs to the need lines for the function
                for glob_obj in file_info_obj.symbol_to_statement.get(sym):
                    
                    if glob_obj in already_included_global_obj:
                        #IF this global statement has already been added continue
                        continue

                    # Add the lines numbers and place it in the already included set
                    p_function.add_line_numbers(glob_obj.get_line_no())
                    already_included_global_obj.add(glob_obj)


                    # include this statements 
                    all_used_symbols = all_used_symbols.union(set(g.get_name() for g in glob_obj.get_symbols()))

                    # Get the set of symbols that this statement depends on
                    set_symbols = file_info_obj.statement_to_symbol.get(glob_obj)
                    # Remove the symbols that have already been included
                    new_needed_symbols = set_symbols.difference(already_included_symbols) 
                    actual_new_needed_symbols = new_needed_symbols.difference(remaining_symbols)
                    #print(f&#34;------------------{actual_new_needed_symbols}&#34;)
                    # Add the actually needed new symbols to the set of symbols to be looped over next
                    next_symbols = next_symbols.union(actual_new_needed_symbols)

        print(f&#34;{function_name}: {all_used_symbols}&#34;)
        for s in all_used_symbols:
            if s in file_info_obj.imported_symbol_to_global_statement:
                print(f&#34;ADDING {s} import statement to {function_name}&#34;)
                p_function.add_line_numbers(file_info_obj.imported_symbol_to_global_statement.get(s).get_line_no())

        #finally add the parsed function object to the file info
        file_info_obj.add_parsed_functions(p_function)
                   

    for f in file_info_obj.parsed_functions:
        print(f&#34;{f.needed_line_numbers}&#34;)


    return file_info_obj</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.cdev.parser" href="index.html">src.cdev.parser</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.cdev.parser.parser_utils.get_file_information" href="#src.cdev.parser.parser_utils.get_file_information">get_file_information</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>